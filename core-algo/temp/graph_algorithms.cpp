#include "graph_algorithms.hpp"

namespace graph_algorithms{

std::vector<int> euler_tour(const std::vector<std::vector<int>> &adjacency_list ){
/**
 * Returns an Eulerian Cycle passing through all edges in the graph generated by
 * adjacency_list.
 *
 * Implementation inspired by:
 * https://cp-algorithms.com/graph/euler_path.html
 *
 * NOTES: 
 * - This will fail in case the adjacency matrix is not symmetric.
 * - This assumes that the graph is connected.
 * - This will raise an exception if there are degrees which are not even.
 */


    int n = adjacency_list.size();

    // Makes Adjacency Matrix for the smaller graph
    std::vector< std::vector<int> > adjacency_matrix(n);
    for(int i=0; i<n; ++i){
        adjacency_matrix[i].resize(n);
    }

    // Degree List
    std::vector<int> degrees;
    degrees.resize(n);

    for(int i=0; i<n; ++i){
        for(auto j : adjacency_list[i]){

            degrees[i]++;

            adjacency_matrix[i][j]++;
        }
    }

    for(int i=0; i<n; ++i){
        if( degrees[i] % 2 != 0){
            throw std::exception();
        }
    }

    std::stack<int> st;
    st.push(0);

    std::vector<int> eulerian_cycle;

    while( !st.empty() ){
        int v = st.top();
        int u;

        for(u=0; u<n; ++u){
            if(adjacency_matrix[v][u]){

                adjacency_matrix[v][u]--;
                adjacency_matrix[u][v]--;

                st.push(u);
                break;
            }
        }

        if(u==n){
            eulerian_cycle.push_back(v);
            st.pop();
        }
    }

    return eulerian_cycle;
}


double cost_of_path(const std::vector<std::vector<double>> &adjacency_matrix, std::vector<int> path){
    double cost = 0;
    for(int i=1; i<path.size(); ++i){
        cost += adjacency_matrix[ path[i-1] ][ path[i] ];
    }

    return cost;
}



void best_path_brute_force_aux
(
    const std::vector<std::vector<double>> &adjacency_matrix,
    const std::vector<int> path,
    std::vector<int> &current_path,
    std::vector<bool> &chosen,
    double &min_cost,
    std::vector<int> &best_path
){
/**
 *
 *
 *
 */

    int m = chosen.size();

    int a = path[0];
    int b = path.back();

    if( m+1 == current_path.size() ){

        current_path.push_back(b);
        double cost = cost_of_path(adjacency_matrix, current_path);

        if(min_cost == -1 || cost < min_cost){
            best_path = current_path;
            min_cost = cost;
        }

        current_path.pop_back();

        return;
    }

    for(int i=0; i<m; ++i){
        if( chosen[i] ){
            continue;
        }

        current_path.push_back(path[i+1]);
        chosen[i] = true;

        best_path_brute_force_aux(adjacency_matrix, path, current_path, chosen, min_cost, best_path);

        current_path.pop_back();
        chosen[i] = false;

    }
}


std::vector<int> best_path_brute_force(const std::vector<std::vector<double>> &adjacency_matrix, std::vector<int> path){

    int m = path.size();

    if( m <= 2 ){
        return path;
    }

    int a = path[0];
    int b = path[m-1];

    std::vector<bool> chosen(m-2, false);

    std::vector<int> current_path;
    current_path.push_back(a);

    double min_cost = -1;

    std::vector<int> best_path;

    best_path_brute_force_aux(adjacency_matrix, path, current_path, chosen, min_cost, best_path);

    return best_path;
}

}